<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åå®¹é“æ¸¸æˆ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #8B4513, #D2B48C);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: #F5DEB3;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 20px;
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        h1 {
            color: #8B0000;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: bold;
        }

        .game-controls {
            margin-bottom: 20px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
            color: #654321;
            font-weight: bold;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            background: linear-gradient(145deg, #DEB887, #CD853F);
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            color: #654321;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        button:hover {
            background: linear-gradient(145deg, #CD853F, #DEB887);
            transform: translateY(-2px);
            box-shadow: 3px 3px 8px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .board-container {
            position: relative;
            margin: 0 auto;
            width: 340px;
            height: 600px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(5, 80px);
            gap: 2px;
            background: #8B4513;
            padding: 10px;
            border-radius: 10px;
            border: 3px solid #654321;
            margin-bottom: 10px;
        }

        .cell {
            background: #DEB887;
            border: 1px solid #CD853F;
            border-radius: 3px;
        }

        .pieces-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 328px;
            height: 410px;
            pointer-events: none;
        }

        .piece {
            position: absolute;
            border: 2px solid #654321;
            border-radius: 8px;
            cursor: grab;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s ease;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            user-select: none;
        }

        .piece:hover {
            transform: scale(1.05);
            box-shadow: 3px 3px 8px rgba(0,0,0,0.4);
        }

        .piece.dragging {
            opacity: 0.8;
            z-index: 1000;
            transform: scale(1.1);
            cursor: grabbing;
        }

        .piece.caocao {
            background: linear-gradient(145deg, #2c5aa0, #1e3f73);
            width: 80px;
            height: 164px;
            font-size: 18px;
        }


        .piece.zhaoyun {
            background: linear-gradient(145deg, #f8e71c, #dcc617);
            width: 80px;
            height: 164px;
            font-size: 16px;
            color: #654321;
        }

        .piece.guanyu {
            background: linear-gradient(145deg, #d0021b, #a50116);
            width: 164px;
            height: 80px;
            font-size: 16px;
        }

        .piece.soldier {
            background: linear-gradient(145deg, #bd10e0, #9a0db8);
            width: 80px;
            height: 80px;
            font-size: 14px;
        }

        .exit-area {
            position: absolute;
            bottom: -14px;
            left: 174px;
            width: 80px;
            height: 164px;
            background: #FFD700;
            border: 2px dashed #B8860B;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #8B4513;
        }

        .exit-label {
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #F5DEB3;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 300px;
            width: 90%;
        }

        .modal h2, .modal h3 {
            color: #8B0000;
            margin-bottom: 15px;
        }

        .modal p {
            color: #654321;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .hint-text {
            background: #FFFACD;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #FFD700;
            margin: 15px 0;
            text-align: left;
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 15px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            .control-buttons {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 11px;
            }
        }

        .valid-drop-zone {
            background: rgba(144, 238, 144, 0.5) !important;
        }

        .invalid-drop-zone {
            background: rgba(255, 99, 71, 0.5) !important;
        }

        /* è½¨è¿¹è®°å½•ç›¸å…³æ ·å¼ */
        .trajectory-svg {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            z-index: 600; /* æé«˜å±‚çº§ï¼Œç¡®ä¿åœ¨æ£‹å­ä¸Šæ–¹ */
        }

        .trajectory-line {
            stroke-width: 4;
            fill: none;
            opacity: 0.8;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .trajectory-arrow {
            opacity: 0.8;
        }

        .trajectory-start-point, .trajectory-end-point {
            opacity: 1;
        }

        .current-track { stroke: #FFD700; }
        .history-track-1 { stroke: #FF6B6B; }
        .history-track-2 { stroke: #4ECDC4; }
        .history-track-3 { stroke: #45B7D1; }
        .history-track-4 { stroke: #96CEB4; }

        /* å†å²è®°å½•å¼¹çª—æ ·å¼ */
        .history-modal-content {
            max-width: 500px;
            max-height: 600px;
            overflow-y: auto;
        }

        .history-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .history-item {
            background: #FFFACD;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #FFD700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: #FFF8DC;
            transform: translateX(5px);
        }

        .history-item.selected {
            background: #E6F3FF;
            border-left-color: #007ACC;
        }

        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .history-item-name {
            font-weight: bold;
            color: #8B0000;
        }

        .history-item-stats {
            font-size: 12px;
            color: #666;
        }

        .history-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* ä¿å­˜è½¨è¿¹è¡¨å•æ ·å¼ */
        .save-track-form {
            margin: 15px 0;
        }

        .save-track-form label {
            display: block;
            margin-bottom: 5px;
            color: #654321;
            font-weight: bold;
        }

        .save-track-form input {
            width: 100%;
            padding: 8px;
            border: 2px solid #DEB887;
            border-radius: 5px;
            font-size: 14px;
        }

        .track-stats {
            background: #FFFACD;
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
        }

        .save-track-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* è®°å½•æŒ‰é’®çŠ¶æ€ */
        .btn-recording {
            background: linear-gradient(145deg, #FF6B6B, #FF5252) !important;
            color: white !important;
        }

        /* å¯¹æ¯”é¢æ¿æ ·å¼ */
        .compare-panel {
            background: #F0F8FF;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #87CEEB;
        }

        .compare-panel h4 {
            color: #1E90FF;
            margin: 0 0 15px 0;
            text-align: center;
        }

        .compare-content {
            display: grid;
            gap: 10px;
        }

        .compare-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid;
        }

        .compare-item-name {
            font-weight: bold;
            display: flex;
            align-items: center;
        }

        .compare-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .compare-item-stats {
            font-size: 12px;
            color: #666;
        }

        #close-compare-btn {
            width: 100%;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>åå®¹é“</h1>
        
        <div class="game-controls">
            <div class="game-info">
                <span>æ­¥æ•°: <span id="move-count">0</span></span>
                <span>æœ€ä½³: <span id="best-score">--</span></span>
            </div>
            <div class="control-buttons">
                <button id="hint-btn">æç¤º</button>
                <button id="undo-btn" disabled>æ’¤é”€</button>
                <button id="reset-btn">é‡å¼€</button>
                <button id="track-btn">å¼€å§‹è®°å½•</button>
                <button id="history-btn">å†å²è®°å½•</button>
            </div>
        </div>

        <div class="board-container">
            <!-- è½¨è¿¹SVGå®¹å™¨ -->
            <svg class="trajectory-svg" id="trajectory-svg" width="340" height="420">
                <!-- è½¨è¿¹çº¿æ¡å°†åŠ¨æ€ç”Ÿæˆ -->
            </svg>
            <div class="game-board" id="game-board">
                <!-- æ£‹ç›˜æ ¼å­å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="pieces-container" id="pieces-container">
                <!-- æ£‹å­å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="exit-area">
                <div class="exit-label">å‡ºå£</div>
            </div>
        </div>
    </div>

    <!-- èƒœåˆ©å¼¹çª— -->
    <div class="modal" id="victory-modal">
        <div class="modal-content">
            <h2>ğŸ‰ æ­å–œé€šå…³ï¼</h2>
            <p>æ›¹æ“æˆåŠŸè„±é€ƒåå®¹é“ï¼</p>
            <p>æ€»æ­¥æ•°: <span id="final-moves">0</span></p>
            <p id="new-record" style="display: none; color: #FFD700; font-weight: bold;">ğŸ† æ–°è®°å½•ï¼</p>
            <button id="play-again-btn">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <!-- æç¤ºå¼¹çª— -->
    <div class="modal" id="hint-modal">
        <div class="modal-content">
            <h3>ğŸ’¡ æ¸¸æˆæç¤º</h3>
            <div class="hint-text" id="hint-text"></div>
            <button id="close-hint-btn">çŸ¥é“äº†</button>
        </div>
    </div>

    <!-- å†å²è®°å½•å¼¹çª— -->
    <div class="modal" id="history-modal">
        <div class="modal-content history-modal-content">
            <h3>ğŸ“Š è½¨è¿¹å†å²è®°å½•</h3>
            <div class="history-list" id="history-list">
                <!-- å†å²è®°å½•é¡¹å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="history-controls">
                <button id="compare-btn" disabled>å¯¹æ¯”è½¨è¿¹</button>
                <button id="close-history-btn">å…³é—­</button>
            </div>
            <div class="compare-panel" id="compare-panel" style="display: none;">
                <h4>ğŸ“Š è½¨è¿¹å¯¹æ¯”åˆ†æ</h4>
                <div class="compare-content" id="compare-content">
                    <!-- å¯¹æ¯”æ•°æ®å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
                <button id="close-compare-btn">å…³é—­å¯¹æ¯”</button>
            </div>
        </div>
    </div>

    <!-- ä¿å­˜è½¨è¿¹å¼¹çª— -->
    <div class="modal" id="save-track-modal">
        <div class="modal-content">
            <h3>ğŸ’¾ ä¿å­˜è½¨è¿¹è®°å½•</h3>
            <div class="save-track-form">
                <label for="track-name">è®°å½•åç§°ï¼š</label>
                <input type="text" id="track-name" placeholder="è¾“å…¥è®°å½•åç§°">
            </div>
            <div class="track-stats">
                <p>æ€»æ­¥æ•°: <span id="save-moves">0</span></p>
                <p>ç”¨æ—¶: <span id="save-time">0</span>ç§’</p>
            </div>
            <div class="save-track-controls">
                <button id="confirm-save-btn">ä¿å­˜</button>
                <button id="cancel-save-btn">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        class HuarongdaoGame {
            constructor() {
                this.boardSize = { rows: 5, cols: 4 };
                this.cellSize = 82; // åŒ…å«é—´éš™
                this.moveCount = 0;
                this.moveHistory = [];
                this.bestScore = parseInt(localStorage.getItem('huarongdao-best')) || null;
                this.isDragging = false;
                this.draggedPiece = null;
                this.dragOffset = { x: 0, y: 0 };
                
                // è½¨è¿¹è®°å½•ç›¸å…³å±æ€§
                this.isTracking = false;
                this.currentTrack = null;
                this.trackStartTime = null;
                this.trajectoryManager = new TrajectoryManager();
                this.historyManager = new HistoryManager();
                this.visualizer = new TrajectoryVisualizer();
                
                // æ¸¸æˆæç¤ºæ•°ç»„
                this.hints = [
                    "ç›®æ ‡æ˜¯è®©æ›¹æ“ï¼ˆè“è‰²å¤§æ–¹å—ï¼‰ç§»åŠ¨åˆ°æ£‹ç›˜åº•éƒ¨ä¸­å¤®çš„å‡ºå£ä½ç½®ã€‚",
                    "æ¯æ¬¡åªèƒ½ç§»åŠ¨ä¸€ä¸ªæ£‹å­ä¸€æ ¼ï¼Œæ£‹å­ä¸èƒ½é‡å æˆ–è¶Šç•Œã€‚",
                    "å°å…µä½“ç§¯å°ï¼Œç§»åŠ¨çµæ´»ï¼Œå¯ä»¥ä¸ºå¤§æ£‹å­è®©è·¯ã€‚",
                    "å…³ç¾½å¯ä»¥å·¦å³ç§»åŠ¨ï¼Œåˆ©ç”¨è¿™ä¸ªç‰¹ç‚¹ä¸ºå…¶ä»–æ£‹å­è…¾å‡ºç©ºé—´ã€‚",
                    "èµµäº‘å’Œå¼ é£æ˜¯ç«–ç›´æ£‹å­ï¼Œå¯ä»¥ä¸Šä¸‹ç§»åŠ¨æ¥è°ƒæ•´å¸ƒå±€ã€‚",
                    "å…ˆç§»åŠ¨è¾¹ç¼˜çš„æ£‹å­ï¼Œä¸ºä¸­å¤®çš„æ›¹æ“åˆ›é€ ç§»åŠ¨è·¯å¾„ã€‚",
                    "è§‚å¯Ÿç©ºæ ¼çš„ä½ç½®ï¼Œåˆç†åˆ©ç”¨ç©ºé—´è¿›è¡Œæ£‹å­è°ƒæ¢ã€‚"
                ];

                this.initializePieces();
                this.initializeGame();
                this.bindEvents();
                this.visualizer.initSVG();
            }

            // åˆå§‹åŒ–æ£‹å­çŠ¶æ€ï¼ˆåŸºäºå›¾åƒå¸ƒå±€ï¼‰
            initializePieces() {
                this.pieces = {
                    caocao: {
                        id: 'caocao',
                        name: 'æ›¹æ“',
                        positions: [[1, 4], [2, 4]],
                        size: [2, 1],
                        className: 'caocao'
                    },
                    zhaoyun: {
                        id: 'zhaoyun',
                        name: 'èµµäº‘',
                        positions: [[4, 2], [5, 2]],
                        size: [2, 1],
                        className: 'zhaoyun'
                    },
                    guanyu: {
                        id: 'guanyu',
                        name: 'å…³ç¾½',
                        positions: [[5, 3], [5, 4]],
                        size: [1, 2],
                        className: 'guanyu'
                    },
                    soldier1: {
                        id: 'soldier1',
                        name: 'å…µ',
                        positions: [[4, 3]],
                        size: [1, 1],
                        className: 'soldier'
                    }
                };

                // ä¿å­˜åˆå§‹çŠ¶æ€
                this.initialPieces = JSON.parse(JSON.stringify(this.pieces));
            }

            // åˆå§‹åŒ–æ¸¸æˆ
            initializeGame() {
                this.createBoard();
                this.createPieces();
                this.updateDisplay();
            }

            // åˆ›å»ºæ£‹ç›˜
            createBoard() {
                const gameBoard = document.getElementById('game-board');
                gameBoard.innerHTML = '';
                
                for (let row = 1; row <= this.boardSize.rows; row++) {
                    for (let col = 1; col <= this.boardSize.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        gameBoard.appendChild(cell);
                    }
                }
            }

            // åˆ›å»ºæ£‹å­
            createPieces() {
                const piecesContainer = document.getElementById('pieces-container');
                piecesContainer.innerHTML = '';

                Object.values(this.pieces).forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `piece ${piece.className}`;
                    pieceElement.dataset.pieceId = piece.id;
                    pieceElement.textContent = piece.name;
                    
                    this.positionPiece(pieceElement, piece);
                    piecesContainer.appendChild(pieceElement);
                });
            }

            // å®šä½æ£‹å­
            positionPiece(element, piece) {
                const topLeft = piece.positions[0];
                const left = (topLeft[1] - 1) * this.cellSize;
                const top = (topLeft[0] - 1) * this.cellSize;
                
                element.style.left = `${left}px`;
                element.style.top = `${top}px`;
            }

            // ç»‘å®šäº‹ä»¶
            bindEvents() {
                // æ£‹å­æ‹–æ‹½äº‹ä»¶
                document.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // è§¦æ‘¸äº‹ä»¶
                document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));

                // æŒ‰é’®äº‹ä»¶
                document.getElementById('reset-btn').addEventListener('click', this.resetGame.bind(this));
                document.getElementById('undo-btn').addEventListener('click', this.undoMove.bind(this));
                document.getElementById('hint-btn').addEventListener('click', this.showHint.bind(this));
                document.getElementById('play-again-btn').addEventListener('click', this.resetGame.bind(this));
                document.getElementById('close-hint-btn').addEventListener('click', this.closeHint.bind(this));
                
                // è½¨è¿¹è®°å½•æŒ‰é’®äº‹ä»¶
                document.getElementById('track-btn').addEventListener('click', this.toggleTracking.bind(this));
                document.getElementById('history-btn').addEventListener('click', this.showHistory.bind(this));
                document.getElementById('close-history-btn').addEventListener('click', this.closeHistory.bind(this));
                document.getElementById('compare-btn').addEventListener('click', this.compareTrajectories.bind(this));
                document.getElementById('confirm-save-btn').addEventListener('click', this.confirmSaveTrack.bind(this));
                document.getElementById('cancel-save-btn').addEventListener('click', this.cancelSaveTrack.bind(this));
                document.getElementById('close-compare-btn').addEventListener('click', this.closeCompare.bind(this));
            }

            // é¼ æ ‡æŒ‰ä¸‹
            handleMouseDown(e) {
                if (e.target.classList.contains('piece')) {
                    this.startDrag(e.target, e.clientX, e.clientY);
                    e.preventDefault();
                }
            }

            // é¼ æ ‡ç§»åŠ¨
            handleMouseMove(e) {
                if (this.isDragging) {
                    this.updateDrag(e.clientX, e.clientY);
                    e.preventDefault();
                }
            }

            // é¼ æ ‡é‡Šæ”¾
            handleMouseUp(e) {
                if (this.isDragging) {
                    this.endDrag(e.clientX, e.clientY);
                }
            }

            // è§¦æ‘¸å¼€å§‹
            handleTouchStart(e) {
                if (e.target.classList.contains('piece')) {
                    const touch = e.touches[0];
                    this.startDrag(e.target, touch.clientX, touch.clientY);
                    e.preventDefault();
                }
            }

            // è§¦æ‘¸ç§»åŠ¨
            handleTouchMove(e) {
                if (this.isDragging) {
                    const touch = e.touches[0];
                    this.updateDrag(touch.clientX, touch.clientY);
                    e.preventDefault();
                }
            }

            // è§¦æ‘¸ç»“æŸ
            handleTouchEnd(e) {
                if (this.isDragging) {
                    const touch = e.changedTouches[0];
                    this.endDrag(touch.clientX, touch.clientY);
                }
            }

            // å¼€å§‹æ‹–æ‹½
            startDrag(pieceElement, clientX, clientY) {
                this.isDragging = true;
                this.draggedPiece = pieceElement;
                
                const rect = pieceElement.getBoundingClientRect();
                this.dragOffset = {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
                
                pieceElement.classList.add('dragging');
                this.saveCurrentState();
            }

            // æ›´æ–°æ‹–æ‹½
            updateDrag(clientX, clientY) {
                if (!this.isDragging || !this.draggedPiece) return;

                const boardRect = document.getElementById('pieces-container').getBoundingClientRect();
                const newX = clientX - boardRect.left - this.dragOffset.x;
                const newY = clientY - boardRect.top - this.dragOffset.y;

                this.draggedPiece.style.left = `${newX}px`;
                this.draggedPiece.style.top = `${newY}px`;

                // æ˜¾ç¤ºæœ‰æ•ˆæ”¾ç½®åŒºåŸŸ
                this.highlightDropZones();
            }

            // ç»“æŸæ‹–æ‹½
            endDrag(clientX, clientY) {
                if (!this.isDragging || !this.draggedPiece) return;

                const pieceId = this.draggedPiece.dataset.pieceId;
                const piece = this.pieces[pieceId];
                
                // è®¡ç®—æ–°ä½ç½®
                const boardRect = document.getElementById('pieces-container').getBoundingClientRect();
                const newX = clientX - boardRect.left - this.dragOffset.x;
                const newY = clientY - boardRect.top - this.dragOffset.y;
                
                const newRow = Math.round(newY / this.cellSize) + 1;
                const newCol = Math.round(newX / this.cellSize) + 1;

                // éªŒè¯ç§»åŠ¨
                if (this.isValidMove(piece, newRow, newCol)) {
                    this.movePiece(pieceId, newRow, newCol);
                } else {
                    // æ¢å¤åŸä½ç½®
                    this.positionPiece(this.draggedPiece, piece);
                }

                // æ¸…ç†æ‹–æ‹½çŠ¶æ€
                this.draggedPiece.classList.remove('dragging');
                this.clearDropZoneHighlights();
                this.isDragging = false;
                this.draggedPiece = null;
            }

            // é«˜äº®æœ‰æ•ˆæ”¾ç½®åŒºåŸŸ
            highlightDropZones() {
                if (!this.draggedPiece) return;

                const pieceId = this.draggedPiece.dataset.pieceId;
                const piece = this.pieces[pieceId];
                
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                this.clearDropZoneHighlights();

                // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„ä½ç½®
                for (let row = 1; row <= this.boardSize.rows; row++) {
                    for (let col = 1; col <= this.boardSize.cols; col++) {
                        const cells = this.getCellsForPosition(row, col, piece.size);
                        const isValid = this.isValidMove(piece, row, col);
                        
                        cells.forEach(([r, c]) => {
                            const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (cell) {
                                cell.classList.add(isValid ? 'valid-drop-zone' : 'invalid-drop-zone');
                            }
                        });
                    }
                }
            }

            // æ¸…é™¤æ”¾ç½®åŒºåŸŸé«˜äº®
            clearDropZoneHighlights() {
                document.querySelectorAll('.valid-drop-zone, .invalid-drop-zone').forEach(cell => {
                    cell.classList.remove('valid-drop-zone', 'invalid-drop-zone');
                });
            }

            // éªŒè¯ç§»åŠ¨æ˜¯å¦æœ‰æ•ˆ
            isValidMove(piece, newRow, newCol) {
                // æ£€æŸ¥è¾¹ç•Œ
                const [rows, cols] = piece.size;
                
                // ç‰¹æ®Šå¤„ç†ï¼šå…è®¸æ›¹æ“è¿›å…¥å‡ºå£åŒºåŸŸï¼ˆç¬¬6è¡Œç¬¬3åˆ—ï¼‰
                if (piece.id === 'caocao' && newRow === 6 && newCol === 3) {
                    // æ›¹æ“ç§»åŠ¨åˆ°å‡ºå£åŒºåŸŸï¼Œæ£€æŸ¥æ˜¯å¦åªç§»åŠ¨äº†ä¸€æ ¼
                    const currentPos = piece.positions[0];
                    const distance = Math.abs(newRow - currentPos[0]) + Math.abs(newCol - currentPos[1]);
                    if (distance !== 1) {
                        return false;
                    }
                    // å‡ºå£åŒºåŸŸä¸éœ€è¦æ£€æŸ¥å ç”¨ï¼ˆæ€»æ˜¯ç©ºçš„ï¼‰
                    return true;
                }
                
                // æ™®é€šè¾¹ç•Œæ£€æŸ¥
                if (newRow < 1 || newCol < 1 || 
                    newRow + rows - 1 > this.boardSize.rows || 
                    newCol + cols - 1 > this.boardSize.cols) {
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦åªç§»åŠ¨äº†ä¸€æ ¼
                const currentPos = piece.positions[0];
                const distance = Math.abs(newRow - currentPos[0]) + Math.abs(newCol - currentPos[1]);
                if (distance !== 1) {
                    return false;
                }

                // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦è¢«å ç”¨
                const newPositions = this.getCellsForPosition(newRow, newCol, piece.size);
                return !this.isPositionOccupied(newPositions, piece.id);
            }

            // è·å–æŒ‡å®šä½ç½®å’Œå¤§å°çš„æ‰€æœ‰æ ¼å­
            getCellsForPosition(row, col, size) {
                const [rows, cols] = size;
                const cells = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        cells.push([row + r, col + c]);
                    }
                }
                return cells;
            }

            // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨
            isPositionOccupied(positions, excludePieceId) {
                const occupiedPositions = new Set();
                
                Object.values(this.pieces).forEach(piece => {
                    if (piece.id !== excludePieceId) {
                        piece.positions.forEach(pos => {
                            occupiedPositions.add(`${pos[0]},${pos[1]}`);
                        });
                    }
                });

                return positions.some(pos => 
                    occupiedPositions.has(`${pos[0]},${pos[1]}`)
                );
            }

            // ç§»åŠ¨æ£‹å­
            movePiece(pieceId, newRow, newCol) {
                const piece = this.pieces[pieceId];
                const oldPositions = [...piece.positions]; // ä¿å­˜ç§»åŠ¨å‰ä½ç½®
                const newPositions = this.getCellsForPosition(newRow, newCol, piece.size);
                
                piece.positions = newPositions;
                
                const pieceElement = document.querySelector(`[data-piece-id="${pieceId}"]`);
                this.positionPiece(pieceElement, piece);
                
                this.moveCount++;
                this.updateDisplay();
                
                // è®°å½•è½¨è¿¹
                if (this.isTracking && this.currentTrack) {
                    this.trajectoryManager.addMove(pieceId, oldPositions[0], newPositions[0]);
                    this.visualizer.updateCurrentTrajectory(this.currentTrack);
                }
                
                // æ–°å¢ï¼šè‡ªåŠ¨ç§»åŠ¨æ£€æµ‹ - å½“æ›¹æ“åˆ°è¾¾(4,3)-(5,3)æ—¶è‡ªåŠ¨ç§»åŠ¨åˆ°å‡ºå£
                if (pieceId === 'caocao' && 
                    newPositions.some(pos => pos[0] === 4 && pos[1] === 3) &&
                    newPositions.some(pos => pos[0] === 5 && pos[1] === 3)) {
                    
                    // å»¶è¿Ÿè‡ªåŠ¨ç§»åŠ¨åˆ°å‡ºå£ä½ç½®
                    setTimeout(() => {
                        // è‡ªåŠ¨è®¾ç½®æ›¹æ“åˆ°å‡ºå£ä½ç½®(5,3)-(6,3)
                        this.pieces.caocao.positions = [[5, 3], [6, 3]];
                        this.positionPiece(pieceElement, this.pieces.caocao);
                        
                        // è§¦å‘èƒœåˆ©
                        setTimeout(() => this.showVictory(), 300);
                    }, 500); // 0.5ç§’å»¶è¿Ÿè®©ç©å®¶çœ‹åˆ°ç§»åŠ¨æ•ˆæœ
                    
                    return; // é¿å…æ‰§è¡Œä¸‹é¢çš„èƒœåˆ©æ£€æŸ¥
                }
                
                // ç‰¹æ®Šæ£€æµ‹ï¼šæ›¹æ“è¿›å…¥å‡ºå£åŒºåŸŸç«‹å³èƒœåˆ©
                if (pieceId === 'caocao' && newPositions.some(pos => pos[0] === 6 && pos[1] === 3)) {
                    setTimeout(() => this.showVictory(), 300);
                    return;
                }
                
                // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
                if (this.checkVictory()) {
                    setTimeout(() => this.showVictory(), 300);
                }
            }

            // ä¿å­˜å½“å‰çŠ¶æ€
            saveCurrentState() {
                this.moveHistory.push({
                    pieces: JSON.parse(JSON.stringify(this.pieces)),
                    moveCount: this.moveCount
                });
            }

            // æ’¤é”€ç§»åŠ¨
            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastState = this.moveHistory.pop();
                this.pieces = lastState.pieces;
                this.moveCount = lastState.moveCount;
                
                this.createPieces();
                this.updateDisplay();
            }

            // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
            checkVictory() {
                const caocao = this.pieces.caocao;
                // èƒœåˆ©æ¡ä»¶ï¼šæ›¹æ“çš„ä¸€æ ¼å æ®å‡ºå£åŒºåŸŸ(ç¬¬6è¡Œç¬¬3åˆ—)
                return caocao.positions.some(pos => 
                    pos[0] === 6 && pos[1] === 3
                );
            }

            // æ˜¾ç¤ºèƒœåˆ©ç•Œé¢
            showVictory() {
                // å¦‚æœæ­£åœ¨è®°å½•è½¨è¿¹ï¼Œè‡ªåŠ¨åœæ­¢å¹¶ä¿å­˜
                if (this.isTracking && this.currentTrack && this.currentTrack.moves.length > 0) {
                    this.isTracking = false;
                    this.trajectoryManager.stopTracking();
                    
                    // ç”Ÿæˆèƒœåˆ©è®°å½•çš„é»˜è®¤åç§°
                    const now = new Date();
                    const defaultName = `èƒœåˆ©-${now.getMonth()+1}æœˆ${now.getDate()}æ—¥ ${now.getHours()}:${now.getMinutes().toString().padStart(2, '0')}`;
                    
                    // å®Œå–„è½¨è¿¹ä¿¡æ¯
                    this.currentTrack.name = defaultName;
                    this.currentTrack.endTime = Date.now();
                    this.currentTrack.isComplete = true; // èƒœåˆ©è®°å½•æ ‡è®°ä¸ºå®Œæˆ
                    
                    // è‡ªåŠ¨ä¿å­˜åˆ°å†å²è®°å½•
                    this.historyManager.saveTrack(this.currentTrack, defaultName);
                    
                    // é‡ç½®è®°å½•æŒ‰é’®çŠ¶æ€
                    const trackBtn = document.getElementById('track-btn');
                    trackBtn.textContent = 'å¼€å§‹è®°å½•';
                    trackBtn.classList.remove('btn-recording');
                    
                    this.currentTrack = null;
                }
                
                document.getElementById('final-moves').textContent = this.moveCount;
                
                // æ£€æŸ¥æ˜¯å¦åˆ›é€ æ–°è®°å½•
                const newRecordElement = document.getElementById('new-record');
                if (!this.bestScore || this.moveCount < this.bestScore) {
                    this.bestScore = this.moveCount;
                    localStorage.setItem('huarongdao-best', this.bestScore);
                    newRecordElement.style.display = 'block';
                } else {
                    newRecordElement.style.display = 'none';
                }
                
                document.getElementById('victory-modal').classList.add('show');
                this.updateDisplay();
            }

            // æ˜¾ç¤ºæç¤º
            showHint() {
                const randomHint = this.hints[Math.floor(Math.random() * this.hints.length)];
                document.getElementById('hint-text').textContent = randomHint;
                document.getElementById('hint-modal').classList.add('show');
            }

            // å…³é—­æç¤º
            closeHint() {
                document.getElementById('hint-modal').classList.remove('show');
            }

            // é‡ç½®æ¸¸æˆ
            resetGame() {
                // å¦‚æœæ­£åœ¨è®°å½•è½¨è¿¹ï¼Œåœæ­¢è®°å½•ï¼ˆä½†ä¸ä¿å­˜ï¼Œå› ä¸ºæ¸¸æˆè¢«é‡ç½®ï¼‰
                if (this.isTracking) {
                    this.isTracking = false;
                    this.trajectoryManager.stopTracking();
                    
                    // é‡ç½®è®°å½•æŒ‰é’®çŠ¶æ€
                    const trackBtn = document.getElementById('track-btn');
                    trackBtn.textContent = 'å¼€å§‹è®°å½•';
                    trackBtn.classList.remove('btn-recording');
                    
                    this.currentTrack = null;
                }
                
                this.pieces = JSON.parse(JSON.stringify(this.initialPieces));
                this.moveCount = 0;
                this.moveHistory = [];
                
                this.createPieces();
                this.updateDisplay();
                
                // å…³é—­å¼¹çª—
                document.getElementById('victory-modal').classList.remove('show');
                document.getElementById('hint-modal').classList.remove('show');
            }

            // æ›´æ–°æ˜¾ç¤º
            updateDisplay() {
                document.getElementById('move-count').textContent = this.moveCount;
                document.getElementById('best-score').textContent = this.bestScore || '--';
                document.getElementById('undo-btn').disabled = this.moveHistory.length === 0;
            }
            
            // è½¨è¿¹è®°å½•ç›¸å…³æ–¹æ³•
            toggleTracking() {
                const trackBtn = document.getElementById('track-btn');
                
                if (!this.isTracking) {
                    // å¼€å§‹è®°å½•
                    this.isTracking = true;
                    this.trackStartTime = Date.now();
                    this.currentTrack = this.trajectoryManager.startTracking();
                    trackBtn.textContent = 'åœæ­¢è®°å½•';
                    trackBtn.classList.add('btn-recording');
                } else {
                    // åœæ­¢è®°å½•
                    this.isTracking = false;
                    this.trajectoryManager.stopTracking();
                    trackBtn.textContent = 'å¼€å§‹è®°å½•';
                    trackBtn.classList.remove('btn-recording');
                    
                    // å¦‚æœæœ‰ç§»åŠ¨è®°å½•ï¼Œæ˜¾ç¤ºä¿å­˜å¯¹è¯æ¡†
                    if (this.currentTrack && this.currentTrack.moves.length > 0) {
                        this.showSaveDialog();
                    } else {
                        // å¦‚æœæ²¡æœ‰ç§»åŠ¨è®°å½•ï¼Œç›´æ¥æ¸…ç©ºcurrentTrack
                        this.currentTrack = null;
                    }
                }
            }
            
            showHistory() {
                this.renderHistoryList();
                document.getElementById('history-modal').classList.add('show');
            }
            
            closeHistory() {
                document.getElementById('history-modal').classList.remove('show');
                document.getElementById('compare-panel').style.display = 'none';
                this.visualizer.clearTrajectories();
            }
            
            renderHistoryList() {
                const historyList = document.getElementById('history-list');
                const tracks = this.historyManager.loadTracks();
                
                if (tracks.length === 0) {
                    historyList.innerHTML = '<p style="text-align: center; color: #666;">æš‚æ— å†å²è®°å½•</p>';
                    return;
                }
                
                historyList.innerHTML = tracks.map((track, index) => `
                    <div class="history-item" data-track-id="${track.id}">
                        <div class="history-item-header">
                            <span class="history-item-name">${track.name}</span>
                            <span class="history-item-stats">${track.totalMoves}æ­¥</span>
                        </div>
                        <div class="history-item-stats">
                            ${new Date(track.startTime).toLocaleString()}
                            ${track.isComplete ? 'âœ… å·²å®Œæˆ' : 'âŒ æœªå®Œæˆ'}
                        </div>
                    </div>
                `).join('');
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                historyList.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', () => {
                        item.classList.toggle('selected');
                        this.updateCompareButton();
                        this.updateTrajectoryDisplay();
                    });
                });
            }
            
            updateCompareButton() {
                const selectedItems = document.querySelectorAll('.history-item.selected');
                document.getElementById('compare-btn').disabled = selectedItems.length < 2;
            }
            
            updateTrajectoryDisplay() {
                this.visualizer.clearTrajectories();
                const selectedItems = document.querySelectorAll('.history-item.selected');
                
                selectedItems.forEach((item, index) => {
                    const trackId = item.dataset.trackId;
                    const track = this.historyManager.getTrackById(trackId);
                    if (track) {
                        this.visualizer.drawTrajectory(track, index + 1);
                    }
                });
            }
            
            compareTrajectories() {
                const selectedItems = document.querySelectorAll('.history-item.selected');
                console.log('Selected items for comparison:', selectedItems.length);
                
                if (selectedItems.length < 2) {
                    alert('è¯·è‡³å°‘é€‰æ‹©2æ¡è½¨è¿¹è¿›è¡Œå¯¹æ¯”');
                    return;
                }
                
                // æ¸…é™¤å½“å‰æ˜¾ç¤ºçš„è½¨è¿¹
                this.visualizer.clearTrajectories();
                console.log('Cleared existing trajectories');
                
                // æ”¶é›†é€‰ä¸­çš„è½¨è¿¹æ•°æ®å’Œå¯¹æ¯”ä¿¡æ¯
                const compareData = [];
                selectedItems.forEach((item, index) => {
                    const trackId = item.dataset.trackId;
                    const track = this.historyManager.getTrackById(trackId);
                    console.log(`Track ${index}:`, track);
                    
                    if (track) {
                        compareData.push({
                            track: track,
                            colorIndex: index + 1,
                            name: track.name,
                            moves: track.totalMoves,
                            duration: track.endTime ? Math.round((track.endTime - track.startTime) / 1000) : 0,
                            completed: track.isComplete
                        });
                        
                        // ç»˜åˆ¶è½¨è¿¹
                        console.log(`Drawing trajectory ${index + 1} with ${track.moves.length} moves`);
                        this.visualizer.drawTrajectory(track, index + 1);
                    }
                });
                
                // æ˜¾ç¤ºå¯¹æ¯”ä¿¡æ¯é¢æ¿
                this.showComparePanel(compareData);
            }
            
            showSaveDialog() {
                const saveModal = document.getElementById('save-track-modal');
                const trackNameInput = document.getElementById('track-name');
                const saveMoves = document.getElementById('save-moves');
                const saveTime = document.getElementById('save-time');
                
                // ç”Ÿæˆé»˜è®¤åç§°
                const now = new Date();
                const defaultName = `å°è¯•${now.getMonth()+1}-${now.getDate()} ${now.getHours()}:${now.getMinutes().toString().padStart(2, '0')}`;
                trackNameInput.value = defaultName;
                
                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                saveMoves.textContent = this.currentTrack.totalMoves;
                const duration = Math.round((Date.now() - this.trackStartTime) / 1000);
                saveTime.textContent = duration;
                
                saveModal.classList.add('show');
            }
            
            confirmSaveTrack() {
                const trackName = document.getElementById('track-name').value.trim();
                if (!trackName) {
                    alert('è¯·è¾“å…¥è®°å½•åç§°');
                    return;
                }
                
                // æ·»åŠ nullæ£€æŸ¥
                if (!this.currentTrack) {
                    console.error('å½“å‰è½¨è¿¹ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
                    alert('ä¿å­˜å¤±è´¥ï¼šè½¨è¿¹æ•°æ®ä¸¢å¤±');
                    this.cancelSaveTrack();
                    return;
                }
                
                // å®Œå–„è½¨è¿¹ä¿¡æ¯
                this.currentTrack.name = trackName;
                this.currentTrack.endTime = Date.now();
                this.currentTrack.isComplete = this.checkVictory();
                
                // ä¿å­˜åˆ°å†å²è®°å½•
                this.historyManager.saveTrack(this.currentTrack, trackName);
                
                // å…³é—­å¯¹è¯æ¡†
                document.getElementById('save-track-modal').classList.remove('show');
                
                // ç°åœ¨æ¸…ç©ºcurrentTrack
                this.currentTrack = null;
            }
            
            cancelSaveTrack() {
                document.getElementById('save-track-modal').classList.remove('show');
                this.currentTrack = null;
            }
            
            showComparePanel(compareData) {
                const comparePanel = document.getElementById('compare-panel');
                const compareContent = document.getElementById('compare-content');
                
                // ç”Ÿæˆå¯¹æ¯”å†…å®¹
                const compareHTML = compareData.map((data, index) => {
                    const color = this.visualizer.colors[data.colorIndex];
                    return `
                        <div class="compare-item" style="border-left-color: ${color};">
                            <div class="compare-item-name">
                                <div class="compare-color-indicator" style="background-color: ${color};"></div>
                                ${data.name}
                                ${data.completed ? 'âœ…' : 'âŒ'}
                            </div>
                            <div class="compare-item-stats">
                                ${data.moves}æ­¥ | ${data.duration}ç§’
                            </div>
                        </div>
                    `;
                }).join('');
                
                // æ·»åŠ æœ€ä½³è®°å½•åˆ†æ
                const bestMoves = Math.min(...compareData.map(d => d.moves));
                const bestTime = Math.min(...compareData.filter(d => d.duration > 0).map(d => d.duration));
                const completedCount = compareData.filter(d => d.completed).length;
                
                const summaryHTML = `
                    <div style="margin-top: 15px; padding: 10px; background: #FFFACD; border-radius: 5px;">
                        <strong>ğŸ“ˆ å¯¹æ¯”åˆ†æï¼š</strong><br>
                        æœ€å°‘æ­¥æ•°: ${bestMoves}æ­¥ | æœ€çŸ­ç”¨æ—¶: ${bestTime > 0 ? bestTime + 'ç§’' : 'æœªçŸ¥'}<br>
                        å®Œæˆç‡: ${completedCount}/${compareData.length}
                    </div>
                `;
                
                compareContent.innerHTML = compareHTML + summaryHTML;
                comparePanel.style.display = 'block';
            }
            
            closeCompare() {
                document.getElementById('compare-panel').style.display = 'none';
                this.visualizer.clearTrajectories();
            }
        }

        // è½¨è¿¹ç®¡ç†å™¨
        class TrajectoryManager {
            constructor() {
                this.tracks = [];
                this.currentTrackId = null;
            }
            
            startTracking() {
                const track = {
                    id: `track_${Date.now()}`,
                    name: '',
                    startTime: Date.now(),
                    endTime: null,
                    moves: [],
                    totalMoves: 0,
                    isComplete: false
                };
                
                this.tracks.push(track);
                this.currentTrackId = track.id;
                return track;
            }
            
            stopTracking() {
                this.currentTrackId = null;
            }
            
            addMove(pieceId, fromPos, toPos) {
                const currentTrack = this.getCurrentTrack();
                if (!currentTrack) return;
                
                const move = {
                    pieceId: pieceId,
                    from: { row: fromPos[0], col: fromPos[1] },
                    to: { row: toPos[0], col: toPos[1] },
                    timestamp: Date.now(),
                    moveNumber: currentTrack.moves.length + 1
                };
                
                console.log('Recording move:', move); // æ·»åŠ è°ƒè¯•
                currentTrack.moves.push(move);
                currentTrack.totalMoves = currentTrack.moves.length;
            }
            
            getCurrentTrack() {
                return this.tracks.find(track => track.id === this.currentTrackId);
            }
        }
        
        // å†å²è®°å½•ç®¡ç†å™¨
        class HistoryManager {
            constructor() {
                this.storageKey = 'huarongdao-tracks';
            }
            
            saveTrack(track, name) {
                const tracks = this.loadTracks();
                track.name = name;
                tracks.push(track);
                localStorage.setItem(this.storageKey, JSON.stringify(tracks));
            }
            
            loadTracks() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : [];
                } catch (e) {
                    console.error('åŠ è½½å†å²è®°å½•å¤±è´¥:', e);
                    return [];
                }
            }
            
            deleteTrack(trackId) {
                const tracks = this.loadTracks();
                const filteredTracks = tracks.filter(track => track.id !== trackId);
                localStorage.setItem(this.storageKey, JSON.stringify(filteredTracks));
            }
            
            getTrackById(trackId) {
                const tracks = this.loadTracks();
                return tracks.find(track => track.id === trackId);
            }
        }
        
        // è½¨è¿¹å¯è§†åŒ–å™¨
        class TrajectoryVisualizer {
            constructor() {
                this.svg = null;
                this.colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                this.cellSize = 82;
            }
            
            initSVG() {
                this.svg = document.getElementById('trajectory-svg');
            }
            
            drawTrajectory(track, colorIndex = 0) {
                if (!this.svg || !track.moves.length) return;
                
                const color = this.colors[colorIndex % this.colors.length];
                const className = colorIndex === 0 ? 'current-track' : `history-track-${colorIndex}`;
                
                // ä¸ºæ¯ä¸ªæ£‹å­ç»˜åˆ¶è½¨è¿¹
                const pieceTrajectories = {};
                
                track.moves.forEach(move => {
                    if (!pieceTrajectories[move.pieceId]) {
                        pieceTrajectories[move.pieceId] = [];
                    }
                    pieceTrajectories[move.pieceId].push(move);
                });
                
                Object.entries(pieceTrajectories).forEach(([pieceId, moves]) => {
                    this.drawPieceTrajectory(moves, color, className, pieceId);
                });
            }
            
            drawPieceTrajectory(moves, color, className, pieceId) {
                console.log('Drawing piece trajectory for:', pieceId, 'moves:', moves.length);
                
                if (moves.length === 0) return;
                
                // ä¸ºæ¯ä¸ªç§»åŠ¨ç»˜åˆ¶å•ç‹¬çš„çº¿æ®µ
                moves.forEach((move, index) => {
                    const fromPos = this.calculatePosition(move.from.row, move.from.col);
                    const toPos = this.calculatePosition(move.to.row, move.to.col);
                    
                    console.log(`Move ${index}: from (${move.from.row},${move.from.col}) to (${move.to.row},${move.to.col})`);
                    console.log(`SVG positions: from (${fromPos.x},${fromPos.y}) to (${toPos.x},${toPos.y})`);
                    
                    // åˆ›å»ºçº¿æ®µ
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromPos.x);
                    line.setAttribute('y1', fromPos.y);
                    line.setAttribute('x2', toPos.x);
                    line.setAttribute('y2', toPos.y);
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', '4');
                    line.setAttribute('stroke-opacity', '0.8');
                    line.setAttribute('class', `trajectory-line ${className}`);
                    line.setAttribute('data-piece', pieceId);
                    line.setAttribute('data-move', index);
                    
                    this.svg.appendChild(line);
                    
                    // æ·»åŠ ç®­å¤´æŒ‡ç¤ºæ–¹å‘
                    this.addArrowHead(fromPos, toPos, color, index);
                });
                
                // æ·»åŠ èµ·ç‚¹å’Œç»ˆç‚¹æ ‡è®°
                this.addTrajectoryPoints(moves, color, pieceId);
            }
            
            addArrowHead(fromPos, toPos, color, moveIndex) {
                const arrowSize = 6;
                const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
                
                // è®¡ç®—ç®­å¤´ä½ç½®ï¼ˆçº¿æ®µä¸­ç‚¹ç¨å¾®åå‘ç»ˆç‚¹ï¼‰
                const arrowX = fromPos.x + (toPos.x - fromPos.x) * 0.7;
                const arrowY = fromPos.y + (toPos.y - fromPos.y) * 0.7;
                
                // åˆ›å»ºç®­å¤´è·¯å¾„
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const x1 = arrowX + arrowSize * Math.cos(angle - Math.PI/6);
                const y1 = arrowY + arrowSize * Math.sin(angle - Math.PI/6);
                const x2 = arrowX + arrowSize * Math.cos(angle + Math.PI/6);
                const y2 = arrowY + arrowSize * Math.sin(angle + Math.PI/6);
                
                arrow.setAttribute('points', `${arrowX},${arrowY} ${x1},${y1} ${x2},${y2}`);
                arrow.setAttribute('fill', color);
                arrow.setAttribute('opacity', '0.8');
                arrow.setAttribute('class', 'trajectory-arrow');
                
                this.svg.appendChild(arrow);
            }
            
            addTrajectoryPoints(moves, color, pieceId) {
                if (!moves.length) return;
                
                // èµ·ç‚¹ - è¾ƒå¤§çš„ç©ºå¿ƒåœ†
                const startPos = this.calculatePosition(moves[0].from.row, moves[0].from.col);
                const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                startPoint.setAttribute('cx', startPos.x);
                startPoint.setAttribute('cy', startPos.y);
                startPoint.setAttribute('r', '8');
                startPoint.setAttribute('fill', 'white');
                startPoint.setAttribute('stroke', color);
                startPoint.setAttribute('stroke-width', '3');
                startPoint.setAttribute('class', 'trajectory-start-point');
                this.svg.appendChild(startPoint);
                
                // æ·»åŠ èµ·ç‚¹æ ‡è®°æ–‡å­—
                const startText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                startText.setAttribute('x', startPos.x);
                startText.setAttribute('y', startPos.y + 4);
                startText.setAttribute('text-anchor', 'middle');
                startText.setAttribute('font-size', '10');
                startText.setAttribute('fill', color);
                startText.setAttribute('font-weight', 'bold');
                startText.textContent = 'S';
                this.svg.appendChild(startText);
                
                // ç»ˆç‚¹ - å®å¿ƒåœ†
                const lastMove = moves[moves.length - 1];
                const endPos = this.calculatePosition(lastMove.to.row, lastMove.to.col);
                const endPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                endPoint.setAttribute('cx', endPos.x);
                endPoint.setAttribute('cy', endPos.y);
                endPoint.setAttribute('r', '8');
                endPoint.setAttribute('fill', color);
                endPoint.setAttribute('stroke', 'white');
                endPoint.setAttribute('stroke-width', '2');
                endPoint.setAttribute('class', 'trajectory-end-point');
                this.svg.appendChild(endPoint);
                
                // æ·»åŠ ç»ˆç‚¹æ ‡è®°æ–‡å­—
                const endText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                endText.setAttribute('x', endPos.x);
                endText.setAttribute('y', endPos.y + 4);
                endText.setAttribute('text-anchor', 'middle');
                endText.setAttribute('font-size', '10');
                endText.setAttribute('fill', 'white');
                endText.setAttribute('font-weight', 'bold');
                endText.textContent = 'E';
                this.svg.appendChild(endText);
            }
            
            updateCurrentTrajectory(track) {
                // æ¸…é™¤å½“å‰è½¨è¿¹
                this.svg.querySelectorAll('.current-track').forEach(el => el.remove());
                this.svg.querySelectorAll('[data-current="true"]').forEach(el => el.remove());
                
                // é‡æ–°ç»˜åˆ¶å½“å‰è½¨è¿¹
                this.drawTrajectory(track, 0);
            }
            
            clearTrajectories() {
                if (this.svg) {
                    this.svg.innerHTML = '';
                }
            }
            
            calculatePosition(row, col) {
                // è®¡ç®—æ£‹å­ä¸­å¿ƒä½ç½® - è€ƒè™‘ç½‘æ ¼å¸ƒå±€
                const x = (col - 1) * this.cellSize + this.cellSize / 2;
                const y = (row - 1) * this.cellSize + this.cellSize / 2;
                console.log(`Position for (${row},${col}): (${x},${y})`);
                return { x, y };
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            new HuarongdaoGame();
        });
    </script>
</body>
</html>
